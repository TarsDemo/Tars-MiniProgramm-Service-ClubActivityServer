// Package LifeService comment
// This file was generated by tars2go 1.1.4
// Generated from ClubActivityManager.tars
package LifeService

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/TarsCloud/TarsGo/tars"
	m "github.com/TarsCloud/TarsGo/tars/model"
	"github.com/TarsCloud/TarsGo/tars/protocol/codec"
	"github.com/TarsCloud/TarsGo/tars/protocol/res/basef"
	"github.com/TarsCloud/TarsGo/tars/protocol/res/requestf"
	"github.com/TarsCloud/TarsGo/tars/protocol/tup"
	"github.com/TarsCloud/TarsGo/tars/util/current"
	"github.com/TarsCloud/TarsGo/tars/util/tools"
	"unsafe"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8
var _ = unsafe.Pointer(nil)

//ClubActivityManager struct
type ClubActivityManager struct {
	s m.Servant
}

//CreateClubManager is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) CreateClubManager(wxId string, clubId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(clubId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "CreateClubManager", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 3, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateClubManagerWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) CreateClubManagerWithContext(tarsCtx context.Context, wxId string, clubId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(clubId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "CreateClubManager", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 3, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateClubManagerOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) CreateClubManagerOneWayWithContext(tarsCtx context.Context, wxId string, clubId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(clubId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "CreateClubManager", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateClub is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) CreateClub(clubInfo *ClubInfo, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = clubInfo.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "CreateClub", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateClubWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) CreateClubWithContext(tarsCtx context.Context, clubInfo *ClubInfo, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = clubInfo.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "CreateClub", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateClubOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) CreateClubOneWayWithContext(tarsCtx context.Context, clubInfo *ClubInfo, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = clubInfo.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "CreateClub", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetClubList is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) GetClubList(index int32, wxId string, nextIndex *int32, clubInfoList *[]ClubInfo, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wxId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 3)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*clubInfoList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *clubInfoList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	err = _os.Write_int32(int32((*ErrCode)), 5)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "GetClubList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 3, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(4, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*clubInfoList) = make([]ClubInfo, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = (*clubInfoList)[i0].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 5, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetClubListWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) GetClubListWithContext(tarsCtx context.Context, index int32, wxId string, nextIndex *int32, clubInfoList *[]ClubInfo, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wxId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 3)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*clubInfoList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *clubInfoList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	err = _os.Write_int32(int32((*ErrCode)), 5)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "GetClubList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 3, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(4, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*clubInfoList) = make([]ClubInfo, length)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {

			err = (*clubInfoList)[i1].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 5, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetClubListOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) GetClubListOneWayWithContext(tarsCtx context.Context, index int32, wxId string, nextIndex *int32, clubInfoList *[]ClubInfo, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wxId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 3)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*clubInfoList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *clubInfoList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	err = _os.Write_int32(int32((*ErrCode)), 5)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "GetClubList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetManagerClubList is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) GetManagerClubList(index int32, wxId string, nextIndex *int32, clubInfoList *[]ClubInfo, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wxId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 3)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*clubInfoList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *clubInfoList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	err = _os.Write_int32(int32((*ErrCode)), 5)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "GetManagerClubList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 3, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(4, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*clubInfoList) = make([]ClubInfo, length)
		for i2, e2 := int32(0), length; i2 < e2; i2++ {

			err = (*clubInfoList)[i2].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 5, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetManagerClubListWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) GetManagerClubListWithContext(tarsCtx context.Context, index int32, wxId string, nextIndex *int32, clubInfoList *[]ClubInfo, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wxId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 3)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*clubInfoList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *clubInfoList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	err = _os.Write_int32(int32((*ErrCode)), 5)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "GetManagerClubList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 3, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(4, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*clubInfoList) = make([]ClubInfo, length)
		for i3, e3 := int32(0), length; i3 < e3; i3++ {

			err = (*clubInfoList)[i3].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 5, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetManagerClubListOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) GetManagerClubListOneWayWithContext(tarsCtx context.Context, index int32, wxId string, nextIndex *int32, clubInfoList *[]ClubInfo, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wxId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 3)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*clubInfoList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *clubInfoList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	err = _os.Write_int32(int32((*ErrCode)), 5)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "GetManagerClubList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteClub is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) DeleteClub(clubId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(clubId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "DeleteClub", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteClubWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) DeleteClubWithContext(tarsCtx context.Context, clubId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(clubId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "DeleteClub", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteClubOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) DeleteClubOneWayWithContext(tarsCtx context.Context, clubId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(clubId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "DeleteClub", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteClubManager is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) DeleteClubManager(wxId string, clubId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(clubId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "DeleteClubManager", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 3, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteClubManagerWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) DeleteClubManagerWithContext(tarsCtx context.Context, wxId string, clubId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(clubId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "DeleteClubManager", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 3, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteClubManagerOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) DeleteClubManagerOneWayWithContext(tarsCtx context.Context, wxId string, clubId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(clubId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "DeleteClubManager", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//ApplyForClub is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) ApplyForClub(wxId string, clubId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(clubId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "ApplyForClub", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 3, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//ApplyForClubWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) ApplyForClubWithContext(tarsCtx context.Context, wxId string, clubId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(clubId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "ApplyForClub", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 3, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//ApplyForClubOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) ApplyForClubOneWayWithContext(tarsCtx context.Context, wxId string, clubId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(clubId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "ApplyForClub", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetClubApply is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) GetClubApply(clubId string, index int32, applyStatus int32, nextIndex *int32, applyList *[]ApplyInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(clubId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(index, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(applyStatus, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 4)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*applyList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *applyList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "GetClubApply", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 4, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(5, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*applyList) = make([]ApplyInfo, length)
		for i4, e4 := int32(0), length; i4 < e4; i4++ {

			err = (*applyList)[i4].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetClubApplyWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) GetClubApplyWithContext(tarsCtx context.Context, clubId string, index int32, applyStatus int32, nextIndex *int32, applyList *[]ApplyInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(clubId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(index, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(applyStatus, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 4)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*applyList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *applyList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "GetClubApply", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 4, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(5, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*applyList) = make([]ApplyInfo, length)
		for i5, e5 := int32(0), length; i5 < e5; i5++ {

			err = (*applyList)[i5].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetClubApplyOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) GetClubApplyOneWayWithContext(tarsCtx context.Context, clubId string, index int32, applyStatus int32, nextIndex *int32, applyList *[]ApplyInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(clubId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(index, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(applyStatus, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 4)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*applyList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *applyList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "GetClubApply", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetUserApply is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) GetUserApply(wxId string, index int32, applyStatus int32, nextIndex *int32, applyList *[]ApplyInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(index, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(applyStatus, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 4)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*applyList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *applyList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "GetUserApply", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 4, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(5, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*applyList) = make([]ApplyInfo, length)
		for i6, e6 := int32(0), length; i6 < e6; i6++ {

			err = (*applyList)[i6].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetUserApplyWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) GetUserApplyWithContext(tarsCtx context.Context, wxId string, index int32, applyStatus int32, nextIndex *int32, applyList *[]ApplyInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(index, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(applyStatus, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 4)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*applyList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *applyList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "GetUserApply", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 4, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(5, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*applyList) = make([]ApplyInfo, length)
		for i7, e7 := int32(0), length; i7 < e7; i7++ {

			err = (*applyList)[i7].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetUserApplyOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) GetUserApplyOneWayWithContext(tarsCtx context.Context, wxId string, index int32, applyStatus int32, nextIndex *int32, applyList *[]ApplyInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(index, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(applyStatus, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 4)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*applyList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *applyList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "GetUserApply", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//ModifyApplyStatus is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) ModifyApplyStatus(wxId string, clubId string, applyStatus int32, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(clubId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(applyStatus, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "ModifyApplyStatus", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 4, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//ModifyApplyStatusWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) ModifyApplyStatusWithContext(tarsCtx context.Context, wxId string, clubId string, applyStatus int32, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(clubId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(applyStatus, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "ModifyApplyStatus", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 4, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//ModifyApplyStatusOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) ModifyApplyStatusOneWayWithContext(tarsCtx context.Context, wxId string, clubId string, applyStatus int32, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(clubId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(applyStatus, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "ModifyApplyStatus", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteApply is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) DeleteApply(wxId string, clubId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(clubId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "DeleteApply", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 3, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteApplyWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) DeleteApplyWithContext(tarsCtx context.Context, wxId string, clubId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(clubId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "DeleteApply", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 3, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteApplyOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) DeleteApplyOneWayWithContext(tarsCtx context.Context, wxId string, clubId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(clubId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "DeleteApply", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateActivity is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) CreateActivity(wxId string, activityInfo *ActivityInfo, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = activityInfo.WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "CreateActivity", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 3, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateActivityWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) CreateActivityWithContext(tarsCtx context.Context, wxId string, activityInfo *ActivityInfo, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = activityInfo.WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "CreateActivity", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 3, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateActivityOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) CreateActivityOneWayWithContext(tarsCtx context.Context, wxId string, activityInfo *ActivityInfo, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = activityInfo.WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "CreateActivity", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetActivityList is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) GetActivityList(index int32, wxId string, clubId string, nextIndex *int32, activityList *[]map[string]string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wxId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(clubId, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 4)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*activityList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *activityList {

		err = _os.WriteHead(codec.MAP, 0)
		if err != nil {
			return ret, err
		}

		err = _os.Write_int32(int32(len(v)), 0)
		if err != nil {
			return ret, err
		}

		for k8, v8 := range v {

			err = _os.Write_string(k8, 0)
			if err != nil {
				return ret, err
			}

			err = _os.Write_string(v8, 1)
			if err != nil {
				return ret, err
			}

		}
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "GetActivityList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 4, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(5, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*activityList) = make([]map[string]string, length)
		for i9, e9 := int32(0), length; i9 < e9; i9++ {

			err, have = _is.SkipTo(codec.MAP, 0, false)
			if err != nil {
				return ret, err
			}

			if have {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return ret, err
				}

				(*activityList)[i9] = make(map[string]string)
				for i10, e10 := int32(0), length; i10 < e10; i10++ {
					var k10 string
					var v10 string

					err = _is.Read_string(&k10, 0, false)
					if err != nil {
						return ret, err
					}

					err = _is.Read_string(&v10, 1, false)
					if err != nil {
						return ret, err
					}

					(*activityList)[i9][k10] = v10
				}
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetActivityListWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) GetActivityListWithContext(tarsCtx context.Context, index int32, wxId string, clubId string, nextIndex *int32, activityList *[]map[string]string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wxId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(clubId, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 4)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*activityList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *activityList {

		err = _os.WriteHead(codec.MAP, 0)
		if err != nil {
			return ret, err
		}

		err = _os.Write_int32(int32(len(v)), 0)
		if err != nil {
			return ret, err
		}

		for k11, v11 := range v {

			err = _os.Write_string(k11, 0)
			if err != nil {
				return ret, err
			}

			err = _os.Write_string(v11, 1)
			if err != nil {
				return ret, err
			}

		}
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "GetActivityList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 4, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(5, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*activityList) = make([]map[string]string, length)
		for i12, e12 := int32(0), length; i12 < e12; i12++ {

			err, have = _is.SkipTo(codec.MAP, 0, false)
			if err != nil {
				return ret, err
			}

			if have {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return ret, err
				}

				(*activityList)[i12] = make(map[string]string)
				for i13, e13 := int32(0), length; i13 < e13; i13++ {
					var k13 string
					var v13 string

					err = _is.Read_string(&k13, 0, false)
					if err != nil {
						return ret, err
					}

					err = _is.Read_string(&v13, 1, false)
					if err != nil {
						return ret, err
					}

					(*activityList)[i12][k13] = v13
				}
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetActivityListOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) GetActivityListOneWayWithContext(tarsCtx context.Context, index int32, wxId string, clubId string, nextIndex *int32, activityList *[]map[string]string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wxId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(clubId, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 4)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*activityList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *activityList {

		err = _os.WriteHead(codec.MAP, 0)
		if err != nil {
			return ret, err
		}

		err = _os.Write_int32(int32(len(v)), 0)
		if err != nil {
			return ret, err
		}

		for k14, v14 := range v {

			err = _os.Write_string(k14, 0)
			if err != nil {
				return ret, err
			}

			err = _os.Write_string(v14, 1)
			if err != nil {
				return ret, err
			}

		}
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "GetActivityList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//UpdateActivity is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) UpdateActivity(activityInfo *ActivityInfo, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = activityInfo.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "UpdateActivity", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//UpdateActivityWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) UpdateActivityWithContext(tarsCtx context.Context, activityInfo *ActivityInfo, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = activityInfo.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "UpdateActivity", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//UpdateActivityOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) UpdateActivityOneWayWithContext(tarsCtx context.Context, activityInfo *ActivityInfo, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = activityInfo.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "UpdateActivity", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteActivity is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) DeleteActivity(activityId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(activityId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "DeleteActivity", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteActivityWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) DeleteActivityWithContext(tarsCtx context.Context, activityId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(activityId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "DeleteActivity", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteActivityOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) DeleteActivityOneWayWithContext(tarsCtx context.Context, activityId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(activityId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "DeleteActivity", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetActivityDetail is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) GetActivityDetail(activityId string, activityInfo *ActivityInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(activityId, 1)
	if err != nil {
		return ret, err
	}

	err = (*activityInfo).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "GetActivityDetail", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*activityInfo).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetActivityDetailWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) GetActivityDetailWithContext(tarsCtx context.Context, activityId string, activityInfo *ActivityInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(activityId, 1)
	if err != nil {
		return ret, err
	}

	err = (*activityInfo).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "GetActivityDetail", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*activityInfo).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetActivityDetailOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) GetActivityDetailOneWayWithContext(tarsCtx context.Context, activityId string, activityInfo *ActivityInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(activityId, 1)
	if err != nil {
		return ret, err
	}

	err = (*activityInfo).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "GetActivityDetail", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetActivityParticipate is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) GetActivityParticipate(index int32, activityId string, nextIndex *int32, participateList *[]ActivityRecord, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(activityId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 3)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*participateList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *participateList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "GetActivityParticipate", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 3, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(4, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*participateList) = make([]ActivityRecord, length)
		for i15, e15 := int32(0), length; i15 < e15; i15++ {

			err = (*participateList)[i15].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetActivityParticipateWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) GetActivityParticipateWithContext(tarsCtx context.Context, index int32, activityId string, nextIndex *int32, participateList *[]ActivityRecord, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(activityId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 3)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*participateList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *participateList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "GetActivityParticipate", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 3, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(4, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*participateList) = make([]ActivityRecord, length)
		for i16, e16 := int32(0), length; i16 < e16; i16++ {

			err = (*participateList)[i16].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetActivityParticipateOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) GetActivityParticipateOneWayWithContext(tarsCtx context.Context, index int32, activityId string, nextIndex *int32, participateList *[]ActivityRecord, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(activityId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 3)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*participateList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *participateList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "GetActivityParticipate", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//ApplyForActivity is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) ApplyForActivity(wxId string, activityId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(activityId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "ApplyForActivity", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 3, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//ApplyForActivityWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) ApplyForActivityWithContext(tarsCtx context.Context, wxId string, activityId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(activityId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "ApplyForActivity", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 3, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//ApplyForActivityOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) ApplyForActivityOneWayWithContext(tarsCtx context.Context, wxId string, activityId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wxId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(activityId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "ApplyForActivity", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteActivityParticipate is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) DeleteActivityParticipate(activityId string, wxId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(activityId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wxId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "DeleteActivityParticipate", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 3, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteActivityParticipateWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) DeleteActivityParticipateWithContext(tarsCtx context.Context, activityId string, wxId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(activityId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wxId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "DeleteActivityParticipate", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32((*int32)(&(*ErrCode)), 3, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteActivityParticipateOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *ClubActivityManager) DeleteActivityParticipateOneWayWithContext(tarsCtx context.Context, activityId string, wxId string, ErrCode *ErrorCode, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(activityId, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wxId, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32((*ErrCode)), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "DeleteActivityParticipate", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//SetServant sets servant for the service.
func (_obj *ClubActivityManager) SetServant(s m.Servant) {
	_obj.s = s
}

//TarsSetTimeout sets the timeout for the servant which is in ms.
func (_obj *ClubActivityManager) TarsSetTimeout(t int) {
	_obj.s.TarsSetTimeout(t)
}

//TarsSetProtocol sets the protocol for the servant.
func (_obj *ClubActivityManager) TarsSetProtocol(p m.Protocol) {
	_obj.s.TarsSetProtocol(p)
}

//AddServant adds servant  for the service.
func (_obj *ClubActivityManager) AddServant(imp _impClubActivityManager, obj string) {
	tars.AddServant(_obj, imp, obj)
}

//AddServant adds servant  for the service with context.
func (_obj *ClubActivityManager) AddServantWithContext(imp _impClubActivityManagerWithContext, obj string) {
	tars.AddServantWithContext(_obj, imp, obj)
}

type _impClubActivityManager interface {
	CreateClubManager(wxId string, clubId string, ErrCode *ErrorCode) (ret int32, err error)
	CreateClub(clubInfo *ClubInfo, ErrCode *ErrorCode) (ret int32, err error)
	GetClubList(index int32, wxId string, nextIndex *int32, clubInfoList *[]ClubInfo, ErrCode *ErrorCode) (ret int32, err error)
	GetManagerClubList(index int32, wxId string, nextIndex *int32, clubInfoList *[]ClubInfo, ErrCode *ErrorCode) (ret int32, err error)
	DeleteClub(clubId string, ErrCode *ErrorCode) (ret int32, err error)
	DeleteClubManager(wxId string, clubId string, ErrCode *ErrorCode) (ret int32, err error)
	ApplyForClub(wxId string, clubId string, ErrCode *ErrorCode) (ret int32, err error)
	GetClubApply(clubId string, index int32, applyStatus int32, nextIndex *int32, applyList *[]ApplyInfo) (ret int32, err error)
	GetUserApply(wxId string, index int32, applyStatus int32, nextIndex *int32, applyList *[]ApplyInfo) (ret int32, err error)
	ModifyApplyStatus(wxId string, clubId string, applyStatus int32, ErrCode *ErrorCode) (ret int32, err error)
	DeleteApply(wxId string, clubId string, ErrCode *ErrorCode) (ret int32, err error)
	CreateActivity(wxId string, activityInfo *ActivityInfo, ErrCode *ErrorCode) (ret int32, err error)
	GetActivityList(index int32, wxId string, clubId string, nextIndex *int32, activityList *[]map[string]string) (ret int32, err error)
	UpdateActivity(activityInfo *ActivityInfo, ErrCode *ErrorCode) (ret int32, err error)
	DeleteActivity(activityId string, ErrCode *ErrorCode) (ret int32, err error)
	GetActivityDetail(activityId string, activityInfo *ActivityInfo) (ret int32, err error)
	GetActivityParticipate(index int32, activityId string, nextIndex *int32, participateList *[]ActivityRecord) (ret int32, err error)
	ApplyForActivity(wxId string, activityId string, ErrCode *ErrorCode) (ret int32, err error)
	DeleteActivityParticipate(activityId string, wxId string, ErrCode *ErrorCode) (ret int32, err error)
}
type _impClubActivityManagerWithContext interface {
	CreateClubManager(tarsCtx context.Context, wxId string, clubId string, ErrCode *ErrorCode) (ret int32, err error)
	CreateClub(tarsCtx context.Context, clubInfo *ClubInfo, ErrCode *ErrorCode) (ret int32, err error)
	GetClubList(tarsCtx context.Context, index int32, wxId string, nextIndex *int32, clubInfoList *[]ClubInfo, ErrCode *ErrorCode) (ret int32, err error)
	GetManagerClubList(tarsCtx context.Context, index int32, wxId string, nextIndex *int32, clubInfoList *[]ClubInfo, ErrCode *ErrorCode) (ret int32, err error)
	DeleteClub(tarsCtx context.Context, clubId string, ErrCode *ErrorCode) (ret int32, err error)
	DeleteClubManager(tarsCtx context.Context, wxId string, clubId string, ErrCode *ErrorCode) (ret int32, err error)
	ApplyForClub(tarsCtx context.Context, wxId string, clubId string, ErrCode *ErrorCode) (ret int32, err error)
	GetClubApply(tarsCtx context.Context, clubId string, index int32, applyStatus int32, nextIndex *int32, applyList *[]ApplyInfo) (ret int32, err error)
	GetUserApply(tarsCtx context.Context, wxId string, index int32, applyStatus int32, nextIndex *int32, applyList *[]ApplyInfo) (ret int32, err error)
	ModifyApplyStatus(tarsCtx context.Context, wxId string, clubId string, applyStatus int32, ErrCode *ErrorCode) (ret int32, err error)
	DeleteApply(tarsCtx context.Context, wxId string, clubId string, ErrCode *ErrorCode) (ret int32, err error)
	CreateActivity(tarsCtx context.Context, wxId string, activityInfo *ActivityInfo, ErrCode *ErrorCode) (ret int32, err error)
	GetActivityList(tarsCtx context.Context, index int32, wxId string, clubId string, nextIndex *int32, activityList *[]map[string]string) (ret int32, err error)
	UpdateActivity(tarsCtx context.Context, activityInfo *ActivityInfo, ErrCode *ErrorCode) (ret int32, err error)
	DeleteActivity(tarsCtx context.Context, activityId string, ErrCode *ErrorCode) (ret int32, err error)
	GetActivityDetail(tarsCtx context.Context, activityId string, activityInfo *ActivityInfo) (ret int32, err error)
	GetActivityParticipate(tarsCtx context.Context, index int32, activityId string, nextIndex *int32, participateList *[]ActivityRecord) (ret int32, err error)
	ApplyForActivity(tarsCtx context.Context, wxId string, activityId string, ErrCode *ErrorCode) (ret int32, err error)
	DeleteActivityParticipate(tarsCtx context.Context, activityId string, wxId string, ErrCode *ErrorCode) (ret int32, err error)
}

// Dispatch is used to call the server side implemnet for the method defined in the tars file. _withContext shows using context or not.
func (_obj *ClubActivityManager) Dispatch(tarsCtx context.Context, _val interface{}, tarsReq *requestf.RequestPacket, tarsResp *requestf.ResponsePacket, _withContext bool) (err error) {
	var length int32
	var have bool
	var ty byte
	_is := codec.NewReader(tools.Int8ToByte(tarsReq.SBuffer))
	_os := codec.NewBuffer()
	switch tarsReq.SFuncName {
	case "CreateClubManager":
		var wxId string
		var clubId string
		var ErrCode ErrorCode

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&wxId, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&clubId, 2, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("wxId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wxId, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("clubId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&clubId, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wxId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wxId); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["clubId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &clubId); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impClubActivityManager)
			_funRet_, err = _imp.CreateClubManager(wxId, clubId, &ErrCode)
		} else {
			_imp := _val.(_impClubActivityManagerWithContext)
			_funRet_, err = _imp.CreateClubManager(tarsCtx, wxId, clubId, &ErrCode)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(ErrCode), 3)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(int32(ErrCode), 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("ErrCode", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["ErrCode"] = ErrCode

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "CreateClub":
		var clubInfo ClubInfo
		var ErrCode ErrorCode

		if tarsReq.IVersion == basef.TARSVERSION {

			err = clubInfo.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("clubInfo", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = clubInfo.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["clubInfo"])
				if err = json.Unmarshal([]byte(_jsonStr_), &clubInfo); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impClubActivityManager)
			_funRet_, err = _imp.CreateClub(&clubInfo, &ErrCode)
		} else {
			_imp := _val.(_impClubActivityManagerWithContext)
			_funRet_, err = _imp.CreateClub(tarsCtx, &clubInfo, &ErrCode)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(ErrCode), 2)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(int32(ErrCode), 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("ErrCode", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["ErrCode"] = ErrCode

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "GetClubList":
		var index int32
		var wxId string
		var nextIndex int32
		var clubInfoList []ClubInfo
		var ErrCode ErrorCode

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_int32(&index, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&wxId, 2, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("index", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&index, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("wxId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wxId, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["index"])
				if err = json.Unmarshal([]byte(_jsonStr_), &index); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wxId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wxId); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impClubActivityManager)
			_funRet_, err = _imp.GetClubList(index, wxId, &nextIndex, &clubInfoList, &ErrCode)
		} else {
			_imp := _val.(_impClubActivityManagerWithContext)
			_funRet_, err = _imp.GetClubList(tarsCtx, index, wxId, &nextIndex, &clubInfoList, &ErrCode)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(nextIndex, 3)
			if err != nil {
				return err
			}

			err = _os.WriteHead(codec.LIST, 4)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(clubInfoList)), 0)
			if err != nil {
				return err
			}

			for _, v := range clubInfoList {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}

			err = _os.Write_int32(int32(ErrCode), 5)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(nextIndex, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("nextIndex", _os.ToBytes())

			_os.Reset()
			err = _os.WriteHead(codec.LIST, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(clubInfoList)), 0)
			if err != nil {
				return err
			}

			for _, v := range clubInfoList {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}
			_tupRsp_.PutBuffer("clubInfoList", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(int32(ErrCode), 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("ErrCode", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["nextIndex"] = nextIndex
			_rspJson_["clubInfoList"] = clubInfoList
			_rspJson_["ErrCode"] = ErrCode

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "GetManagerClubList":
		var index int32
		var wxId string
		var nextIndex int32
		var clubInfoList []ClubInfo
		var ErrCode ErrorCode

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_int32(&index, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&wxId, 2, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("index", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&index, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("wxId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wxId, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["index"])
				if err = json.Unmarshal([]byte(_jsonStr_), &index); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wxId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wxId); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impClubActivityManager)
			_funRet_, err = _imp.GetManagerClubList(index, wxId, &nextIndex, &clubInfoList, &ErrCode)
		} else {
			_imp := _val.(_impClubActivityManagerWithContext)
			_funRet_, err = _imp.GetManagerClubList(tarsCtx, index, wxId, &nextIndex, &clubInfoList, &ErrCode)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(nextIndex, 3)
			if err != nil {
				return err
			}

			err = _os.WriteHead(codec.LIST, 4)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(clubInfoList)), 0)
			if err != nil {
				return err
			}

			for _, v := range clubInfoList {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}

			err = _os.Write_int32(int32(ErrCode), 5)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(nextIndex, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("nextIndex", _os.ToBytes())

			_os.Reset()
			err = _os.WriteHead(codec.LIST, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(clubInfoList)), 0)
			if err != nil {
				return err
			}

			for _, v := range clubInfoList {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}
			_tupRsp_.PutBuffer("clubInfoList", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(int32(ErrCode), 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("ErrCode", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["nextIndex"] = nextIndex
			_rspJson_["clubInfoList"] = clubInfoList
			_rspJson_["ErrCode"] = ErrCode

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "DeleteClub":
		var clubId string
		var ErrCode ErrorCode

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&clubId, 1, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("clubId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&clubId, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["clubId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &clubId); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impClubActivityManager)
			_funRet_, err = _imp.DeleteClub(clubId, &ErrCode)
		} else {
			_imp := _val.(_impClubActivityManagerWithContext)
			_funRet_, err = _imp.DeleteClub(tarsCtx, clubId, &ErrCode)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(ErrCode), 2)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(int32(ErrCode), 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("ErrCode", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["ErrCode"] = ErrCode

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "DeleteClubManager":
		var wxId string
		var clubId string
		var ErrCode ErrorCode

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&wxId, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&clubId, 2, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("wxId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wxId, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("clubId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&clubId, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wxId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wxId); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["clubId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &clubId); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impClubActivityManager)
			_funRet_, err = _imp.DeleteClubManager(wxId, clubId, &ErrCode)
		} else {
			_imp := _val.(_impClubActivityManagerWithContext)
			_funRet_, err = _imp.DeleteClubManager(tarsCtx, wxId, clubId, &ErrCode)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(ErrCode), 3)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(int32(ErrCode), 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("ErrCode", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["ErrCode"] = ErrCode

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "ApplyForClub":
		var wxId string
		var clubId string
		var ErrCode ErrorCode

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&wxId, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&clubId, 2, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("wxId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wxId, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("clubId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&clubId, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wxId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wxId); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["clubId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &clubId); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impClubActivityManager)
			_funRet_, err = _imp.ApplyForClub(wxId, clubId, &ErrCode)
		} else {
			_imp := _val.(_impClubActivityManagerWithContext)
			_funRet_, err = _imp.ApplyForClub(tarsCtx, wxId, clubId, &ErrCode)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(ErrCode), 3)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(int32(ErrCode), 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("ErrCode", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["ErrCode"] = ErrCode

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "GetClubApply":
		var clubId string
		var index int32
		var applyStatus int32
		var nextIndex int32
		var applyList []ApplyInfo

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&clubId, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&index, 2, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&applyStatus, 3, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("clubId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&clubId, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("index", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&index, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("applyStatus", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&applyStatus, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["clubId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &clubId); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["index"])
				if err = json.Unmarshal([]byte(_jsonStr_), &index); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["applyStatus"])
				if err = json.Unmarshal([]byte(_jsonStr_), &applyStatus); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impClubActivityManager)
			_funRet_, err = _imp.GetClubApply(clubId, index, applyStatus, &nextIndex, &applyList)
		} else {
			_imp := _val.(_impClubActivityManagerWithContext)
			_funRet_, err = _imp.GetClubApply(tarsCtx, clubId, index, applyStatus, &nextIndex, &applyList)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(nextIndex, 4)
			if err != nil {
				return err
			}

			err = _os.WriteHead(codec.LIST, 5)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(applyList)), 0)
			if err != nil {
				return err
			}

			for _, v := range applyList {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(nextIndex, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("nextIndex", _os.ToBytes())

			_os.Reset()
			err = _os.WriteHead(codec.LIST, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(applyList)), 0)
			if err != nil {
				return err
			}

			for _, v := range applyList {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}
			_tupRsp_.PutBuffer("applyList", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["nextIndex"] = nextIndex
			_rspJson_["applyList"] = applyList

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "GetUserApply":
		var wxId string
		var index int32
		var applyStatus int32
		var nextIndex int32
		var applyList []ApplyInfo

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&wxId, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&index, 2, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&applyStatus, 3, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("wxId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wxId, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("index", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&index, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("applyStatus", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&applyStatus, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wxId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wxId); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["index"])
				if err = json.Unmarshal([]byte(_jsonStr_), &index); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["applyStatus"])
				if err = json.Unmarshal([]byte(_jsonStr_), &applyStatus); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impClubActivityManager)
			_funRet_, err = _imp.GetUserApply(wxId, index, applyStatus, &nextIndex, &applyList)
		} else {
			_imp := _val.(_impClubActivityManagerWithContext)
			_funRet_, err = _imp.GetUserApply(tarsCtx, wxId, index, applyStatus, &nextIndex, &applyList)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(nextIndex, 4)
			if err != nil {
				return err
			}

			err = _os.WriteHead(codec.LIST, 5)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(applyList)), 0)
			if err != nil {
				return err
			}

			for _, v := range applyList {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(nextIndex, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("nextIndex", _os.ToBytes())

			_os.Reset()
			err = _os.WriteHead(codec.LIST, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(applyList)), 0)
			if err != nil {
				return err
			}

			for _, v := range applyList {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}
			_tupRsp_.PutBuffer("applyList", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["nextIndex"] = nextIndex
			_rspJson_["applyList"] = applyList

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "ModifyApplyStatus":
		var wxId string
		var clubId string
		var applyStatus int32
		var ErrCode ErrorCode

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&wxId, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&clubId, 2, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&applyStatus, 3, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("wxId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wxId, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("clubId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&clubId, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("applyStatus", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&applyStatus, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wxId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wxId); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["clubId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &clubId); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["applyStatus"])
				if err = json.Unmarshal([]byte(_jsonStr_), &applyStatus); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impClubActivityManager)
			_funRet_, err = _imp.ModifyApplyStatus(wxId, clubId, applyStatus, &ErrCode)
		} else {
			_imp := _val.(_impClubActivityManagerWithContext)
			_funRet_, err = _imp.ModifyApplyStatus(tarsCtx, wxId, clubId, applyStatus, &ErrCode)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(ErrCode), 4)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(int32(ErrCode), 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("ErrCode", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["ErrCode"] = ErrCode

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "DeleteApply":
		var wxId string
		var clubId string
		var ErrCode ErrorCode

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&wxId, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&clubId, 2, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("wxId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wxId, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("clubId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&clubId, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wxId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wxId); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["clubId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &clubId); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impClubActivityManager)
			_funRet_, err = _imp.DeleteApply(wxId, clubId, &ErrCode)
		} else {
			_imp := _val.(_impClubActivityManagerWithContext)
			_funRet_, err = _imp.DeleteApply(tarsCtx, wxId, clubId, &ErrCode)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(ErrCode), 3)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(int32(ErrCode), 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("ErrCode", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["ErrCode"] = ErrCode

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "CreateActivity":
		var wxId string
		var activityInfo ActivityInfo
		var ErrCode ErrorCode

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&wxId, 1, true)
			if err != nil {
				return err
			}

			err = activityInfo.ReadBlock(_is, 2, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("wxId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wxId, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("activityInfo", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = activityInfo.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wxId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wxId); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["activityInfo"])
				if err = json.Unmarshal([]byte(_jsonStr_), &activityInfo); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impClubActivityManager)
			_funRet_, err = _imp.CreateActivity(wxId, &activityInfo, &ErrCode)
		} else {
			_imp := _val.(_impClubActivityManagerWithContext)
			_funRet_, err = _imp.CreateActivity(tarsCtx, wxId, &activityInfo, &ErrCode)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(ErrCode), 3)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(int32(ErrCode), 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("ErrCode", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["ErrCode"] = ErrCode

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "GetActivityList":
		var index int32
		var wxId string
		var clubId string
		var nextIndex int32
		var activityList []map[string]string

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_int32(&index, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&wxId, 2, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&clubId, 3, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("index", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&index, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("wxId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wxId, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("clubId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&clubId, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["index"])
				if err = json.Unmarshal([]byte(_jsonStr_), &index); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wxId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wxId); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["clubId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &clubId); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impClubActivityManager)
			_funRet_, err = _imp.GetActivityList(index, wxId, clubId, &nextIndex, &activityList)
		} else {
			_imp := _val.(_impClubActivityManagerWithContext)
			_funRet_, err = _imp.GetActivityList(tarsCtx, index, wxId, clubId, &nextIndex, &activityList)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(nextIndex, 4)
			if err != nil {
				return err
			}

			err = _os.WriteHead(codec.LIST, 5)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(activityList)), 0)
			if err != nil {
				return err
			}

			for _, v := range activityList {

				err = _os.WriteHead(codec.MAP, 0)
				if err != nil {
					return err
				}

				err = _os.Write_int32(int32(len(v)), 0)
				if err != nil {
					return err
				}

				for k17, v17 := range v {

					err = _os.Write_string(k17, 0)
					if err != nil {
						return err
					}

					err = _os.Write_string(v17, 1)
					if err != nil {
						return err
					}

				}
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(nextIndex, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("nextIndex", _os.ToBytes())

			_os.Reset()
			err = _os.WriteHead(codec.LIST, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(activityList)), 0)
			if err != nil {
				return err
			}

			for _, v := range activityList {

				err = _os.WriteHead(codec.MAP, 0)
				if err != nil {
					return err
				}

				err = _os.Write_int32(int32(len(v)), 0)
				if err != nil {
					return err
				}

				for k18, v18 := range v {

					err = _os.Write_string(k18, 0)
					if err != nil {
						return err
					}

					err = _os.Write_string(v18, 1)
					if err != nil {
						return err
					}

				}
			}
			_tupRsp_.PutBuffer("activityList", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["nextIndex"] = nextIndex
			_rspJson_["activityList"] = activityList

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "UpdateActivity":
		var activityInfo ActivityInfo
		var ErrCode ErrorCode

		if tarsReq.IVersion == basef.TARSVERSION {

			err = activityInfo.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("activityInfo", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = activityInfo.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["activityInfo"])
				if err = json.Unmarshal([]byte(_jsonStr_), &activityInfo); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impClubActivityManager)
			_funRet_, err = _imp.UpdateActivity(&activityInfo, &ErrCode)
		} else {
			_imp := _val.(_impClubActivityManagerWithContext)
			_funRet_, err = _imp.UpdateActivity(tarsCtx, &activityInfo, &ErrCode)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(ErrCode), 2)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(int32(ErrCode), 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("ErrCode", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["ErrCode"] = ErrCode

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "DeleteActivity":
		var activityId string
		var ErrCode ErrorCode

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&activityId, 1, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("activityId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&activityId, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["activityId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &activityId); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impClubActivityManager)
			_funRet_, err = _imp.DeleteActivity(activityId, &ErrCode)
		} else {
			_imp := _val.(_impClubActivityManagerWithContext)
			_funRet_, err = _imp.DeleteActivity(tarsCtx, activityId, &ErrCode)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(ErrCode), 2)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(int32(ErrCode), 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("ErrCode", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["ErrCode"] = ErrCode

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "GetActivityDetail":
		var activityId string
		var activityInfo ActivityInfo

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&activityId, 1, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("activityId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&activityId, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["activityId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &activityId); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impClubActivityManager)
			_funRet_, err = _imp.GetActivityDetail(activityId, &activityInfo)
		} else {
			_imp := _val.(_impClubActivityManagerWithContext)
			_funRet_, err = _imp.GetActivityDetail(tarsCtx, activityId, &activityInfo)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = activityInfo.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = activityInfo.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("activityInfo", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["activityInfo"] = activityInfo

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "GetActivityParticipate":
		var index int32
		var activityId string
		var nextIndex int32
		var participateList []ActivityRecord

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_int32(&index, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&activityId, 2, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("index", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&index, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("activityId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&activityId, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["index"])
				if err = json.Unmarshal([]byte(_jsonStr_), &index); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["activityId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &activityId); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impClubActivityManager)
			_funRet_, err = _imp.GetActivityParticipate(index, activityId, &nextIndex, &participateList)
		} else {
			_imp := _val.(_impClubActivityManagerWithContext)
			_funRet_, err = _imp.GetActivityParticipate(tarsCtx, index, activityId, &nextIndex, &participateList)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(nextIndex, 3)
			if err != nil {
				return err
			}

			err = _os.WriteHead(codec.LIST, 4)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(participateList)), 0)
			if err != nil {
				return err
			}

			for _, v := range participateList {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(nextIndex, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("nextIndex", _os.ToBytes())

			_os.Reset()
			err = _os.WriteHead(codec.LIST, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(participateList)), 0)
			if err != nil {
				return err
			}

			for _, v := range participateList {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}
			_tupRsp_.PutBuffer("participateList", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["nextIndex"] = nextIndex
			_rspJson_["participateList"] = participateList

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "ApplyForActivity":
		var wxId string
		var activityId string
		var ErrCode ErrorCode

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&wxId, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&activityId, 2, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("wxId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wxId, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("activityId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&activityId, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wxId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wxId); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["activityId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &activityId); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impClubActivityManager)
			_funRet_, err = _imp.ApplyForActivity(wxId, activityId, &ErrCode)
		} else {
			_imp := _val.(_impClubActivityManagerWithContext)
			_funRet_, err = _imp.ApplyForActivity(tarsCtx, wxId, activityId, &ErrCode)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(ErrCode), 3)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(int32(ErrCode), 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("ErrCode", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["ErrCode"] = ErrCode

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "DeleteActivityParticipate":
		var activityId string
		var wxId string
		var ErrCode ErrorCode

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&activityId, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&wxId, 2, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("activityId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&activityId, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("wxId", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wxId, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["activityId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &activityId); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wxId"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wxId); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impClubActivityManager)
			_funRet_, err = _imp.DeleteActivityParticipate(activityId, wxId, &ErrCode)
		} else {
			_imp := _val.(_impClubActivityManagerWithContext)
			_funRet_, err = _imp.DeleteActivityParticipate(tarsCtx, activityId, wxId, &ErrCode)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(ErrCode), 3)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(int32(ErrCode), 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("ErrCode", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["ErrCode"] = ErrCode

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

	default:
		return fmt.Errorf("func mismatch")
	}
	var _status map[string]string
	s, ok := current.GetResponseStatus(tarsCtx)
	if ok && s != nil {
		_status = s
	}
	var _context map[string]string
	c, ok := current.GetResponseContext(tarsCtx)
	if ok && c != nil {
		_context = c
	}
	*tarsResp = requestf.ResponsePacket{
		IVersion:     tarsReq.IVersion,
		CPacketType:  0,
		IRequestId:   tarsReq.IRequestId,
		IMessageType: 0,
		IRet:         0,
		SBuffer:      tools.ByteToInt8(_os.ToBytes()),
		Status:       _status,
		SResultDesc:  "",
		Context:      _context,
	}

	_ = _is
	_ = _os
	_ = length
	_ = have
	_ = ty
	return nil
}
